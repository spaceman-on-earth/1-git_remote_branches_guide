# Preamble - Working with remotes



# GIT REMOTE BRANCHES GUIDE

Guide to basic operations with remote branches in Git.  
Russian edition.  

---

Удаленные ветки представляют собой ссылки на состояния веток в удаленных репозиториях. Перемещать их локально вы не можете; они смещаются автоматически при каждом подключении по сети. Удаленные ветки работают как закладки, напоминающие, где в удаленных репозиториях находились соответствующие ветки во время вашего последнего подключения к ним.

Они имеют форму **(имя удаленного репозитория)/(ветка)**. К примеру, чтобы увидеть, как выглядела ветка master на сервере origin во время последнего взаимодействия с ним, проверьте ветку origin/master.  

Проясним ситуацию на примере. Предположим, у вас есть Git-сервер с адресом git.ourcompany.com. При клонировании с этого адреса Git автоматически присваивает копии имя origin, извлекает все данные, создает указатель на местоположение ветки master и присваивает ему локальное имя origin/master. Одновременно вам предоставляется собственная локальная ветка master, берущая начало в том же самом месте, что и одноименная ветка копии, что дает вам отправную точку для начала работы:

![Удаленный и локальный репозитории после клонирования](https://git-scm.com/book/en/v2/images/remote-branches-1.png "Удаленный и локальный репозитории после клонирования")

Если во время вашей работы на локальной ветке master кто-то отправит на сервер git.ourcompany.com результаты своего труда и обновит удаленную ветку master, истории веток будут развиваться по-разному. Кроме того, до момента связи с сервером origin указатель origin/master у вас двигаться не будет:

![Локальная и удалённая работа может расходиться](https://git-scm.com/book/en/v2/images/remote-branches-2.png "Локальная и удаленная версии ветки могут различаться")

Синхронизация работы осуществляется командой **git fetch origin**. Она ищет сервер с именем «origin» (в данном случае это сервер git.ourcompany.com), извлекает оттуда все пока отсутствующие у вас данные, обновляет вашу локальную базу данных и сдвигает указатель origin/master на новую, более актуальную позицию:

![Команда git fetch обновляет ссылки на удаленный репозиторий](https://git-scm.com/book/en/v2/images/remote-branches-3.png "Команда git fetch обновляет ссылки на удаленный репозиторий")

Чтобы продемонстрировать, как будут выглядеть удаленные ветки при наличии нескольких удаленных серверов, предположим, что у вас есть еще один внутренний сервер Git, которым пользуется только одна из групп разработчиков. Этот сервер находится по адресу git.team1.ourcompany.com. Добавить его в качестве новой удаленной ссылки на проект, над которым вы сейчас работаете, можно уже знакомой вам командой **git remote add**. Присвойте этому удаленному серверу имя teamone:

![Добавление еще одного удаленного сервера](https://git-scm.com/book/en/v2/images/remote-branches-4.png "Добавление еще одного удаленного сервера")

Теперь можно воспользоваться командой git fetch teamone и получить все данные, отсутствующие у вас, но имеющиеся на сервере teamone. Однако поскольку пока этот сервер содержит всего лишь часть данных с сервера origin, система Git ничего не скачает, а только сгенерирует удаленную ветку teamone/master, указывающую на тот же коммит, что и ветка master на сервере teamone:

![Удаленная отслеживающая ветка для ветки teamone/master](https://git-scm.com/book/en/v2/images/remote-branches-5.png "Удаленная отслеживающая ветка для ветки teamone/master")

## Отправка данных (git push)

Чтобы поделиться содержимым своей ветки с окружающими, ее нужно отправить на удаленный сервер, на котором у вас есть права на запись. Автоматической синхронизации локальных веток с удаленными серверами не происходит, поэтому ветки, которые вы хотите выставить на всеобщее обозрение, следует отправлять вручную. Такой подход дает возможность работать с личными ветками независимо от коллег, предоставляя доступ только к тематическим веткам, предназначенным для совместной работы.

Предположим, у вас есть ветка serverfix, над которой вы хотите работать вместе с коллегами. Ее следует отправить на сервер командой **git push (удаленный сервер) (ветка)**:

    $ git push origin serverfix
    Counting objects: 24, done.
    Delta compression using up to 8 threads.
    Compressing objects: 100% (15/15), done.
    Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
    Total 24 (delta 2), reused 0 (delta 0)
    To https://github.com/schacon/simplegit
    * [new branch] serverfix -> serverfix

Это в некотором роде сокращение. Система Git автоматически превращает имя ветки serverfix в запись refs/heads/serverfix:refs/heads/serverfix, что означает «возьмите мою локальную ветку serverfix и используйте для обновления удаленной ветки serverfix». Фрагмент refs/heads/, как правило, можно просто опустить. Вы также можете воспользоваться командой **git push origin serverfix:serverfix**, которая делает то же самое. Кроме того, данный формат позволяет переслать содержимое локальной ветки в удаленную ветку с другим именем. Достаточно вместо имени serverfix на удаленном сервере указать другой вариант, например **git push origin serverfix:awesomebranch**. В этом случае содержимое локальной ветки serverfix будет передано в ветку awesomebranch на удаленном сервере.  

> ПРИМЕЧАНИЕ  
> Каждый раз вводить свой пароль не нужно. Если для отправки данных вы используете протокол HTTPS, сервер Git будет просить вас указать имя пользователя и пароль для проверки прав доступа. По умолчанию эту информацию предлагается ввести в терминале, чтобы сервер мог сообщить вам, имеете ли вы право отправлять ему данные. Чтобы не делать этого при каждой отправке, настройте «кэш учетных данных». Проще всего несколько минут держать данную информацию в памяти, что легко достигается командой **git config --global credential.helper cache**.

Когда кто-то из ваших коллег в следующий раз решит скачать обновления с сервера, он получит ссылку в виде удаленной ветки origin/serverfix на то место, куда указывает серверная ветка serverfix:

    $ git fetch origin
    remote: Counting objects: 7, done.
    remote: Compressing objects: 100% (2/2), done.
    remote: Total 3 (delta 0), reused 3 (delta 0)
    Unpacking objects: 100% (3/3), done.
    From https://github.com/schacon/simplegit
    * [new branch] serverfix -> origin/serverfix

Имейте в виду, что получение новых удаленных веток при скачивании данных не означает автоматического появления их доступных для редактирования копий. Другими словами, у вас появляется не новая ветка serverfix, а только недоступный для редактирования указатель origin/serverfix.

Тем не менее, данные оттуда можно слить в текущую рабочую ветку, воспользовавшись командой **git merge origin/serverfix**. Если вам требуется собственная копия ветки serverfix, достаточно создать ее, взяв за основу удаленную ветку:

    $ git checkout -b serverfix origin/serverfix
    Branch serverfix set up to track remote branch serverfix from origin.
    Switched to a new branch 'serverfix'

В результате вы получаете для работы локальную ветку, которая начинается там же, где и ветка origin/serverfix.

## Слежение за ветками
 
При переходе в локальную ветку, созданную из удаленной, автоматически появляется так называемая ветка наблюдения (tracking branch). Это локальная ветка, напрямую связанная с удаленной. Если, находясь на этой ветке, вы наберете команду **git push**, система Git автоматически поймет, на какой сервер и в какую ветку нужно отправлять данные. А команда **git pull** в этом случае скачивает все удаленные ссылки и после этого автоматически выполняет слияние в соответствующую удаленную ветку.  
Ветка, за которой следит локальная называется «upstream branch».

При клонировании репозитория автоматически создается ветка master, следящая за веткой origin/master. Именно поэтому команды *git push и git pull выполняются из этой ветки без аргументов*. При желании можно создавать и другие ветки наблюдения, следящие за ветками на других удаленных серверах или не отслеживающие происходящее на ветке master. Простой пример реализации этого сценария — команда **git checkout -b [ветка] [имя удаленного сервера]/[ветка]**. Это достаточно распространенная операция, для которой в Git существует параметр --track:

    $ git checkout --track origin/serverfix
    Branch serverfix set up to track remote branch serverfix from origin.
    Switched to a new branch 'serverfix'

Если вы хотите, чтобы имя локальной ветки отличалось от имени удаленной ветки, используйте первую версию команды с указанием нового имени:

    $ git checkout -b sf origin/serverfix
    Branch sf set up to track remote branch serverfix from origin.
    Switched to a new branch 'sf'

Теперь локальная ветка sf поддерживает автоматический обмен данными с удаленной веткой origin/serverfix.

Если вы хотите сопоставить только что скачанной удаленной ветке существующую локальную ветку или поменять удаленную ветку, за которой вы следите, используйте параметр **-u** или **--set-upstream-to** команды git branch:

    $ git branch -u origin/serverfix
    Branch serverfix set up to track remote branch serverfix from origin.

Для обращения к существующей ветке наблюдения есть сокращенные формы **@{upstream}** или **@{u}**. К примеру, если из ветки master вы следите за веткой origin/master, для краткости можно писать git merge @{u} вместо git merge origin/master.

Получить список веток наблюдения позволяет параметр **-vv** команды git branch. В результате выводится перечень локальных веток с дополнительной информацией, касающейся того, за чем следит каждая ветка и на сколько она опережает соответствующую ветку на удаленном сервере или отстает от нее:

    $ git branch -vv
    iss53 7e424c3 [origin/iss53: ahead 2] forgot the brackets
    master 1ae2a45 [origin/master] deploying index fix
    * serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
    testing 5ea463a trying something new

Здесь мы видим, что ветка iss53 связана с веткой origin/iss53 и при этом запись «ahead 2» означает наличие двух локальных коммитов, пока не отправленных на сервер. Наша ветка master связана с веткой origin/master и содержит актуальную информацию. А вот ветка serverfix, связанная с веткой server-fix-good на сервере teamone, помечена как «ahead 3, behind 1», то есть на сервере существует коммит, который в нее пока не слит, а на ней присутствуют три коммита, пока не отправленные на сервер. Наконец, мы видим, что ветка testing не связана ни с одной удаленной веткой.

Отметим, что все цифры представляют собой показатели, зафиксированные в момент последнего скачивания данных с каждого сервера. Данная команда не обращается к серверам, а просто сообщает локальные данные из кэша. Для получения актуальной информации о количестве новых коммитов на локальных и удаленных ветках следует извлечь данные со всех удаленных серверов и только затем воспользоваться этой командой. Это можно сделать так:   
**$ git fetch --all; git branch -vv**.

## Получение данных с последующим слиянием (git pull)

Хотя команда **git fetch** забирает с сервера всю пока отсутствующую у вас новую информацию, на состояние рабочей папки она никак не влияет. Она всего лишь предоставляет данные, которые можно подвергнуть слиянию.  

Но существует и команда **git pull**, по сути, представляющая собой команду git fetch, за которой немедленно следует команда git merge. При наличии ветки наблюдения, настроенной, как показано в предыдущем разделе, вручную или в момент ее генерации командой clone или checkout, команда **git pull** будет обращаться к серверу и ветке, за которой наблюдает ваша текущая ветка, скачивать данные с этого сервера и пытаться слить их с вашей веткой.  

В общем случае лучше отдельно пользоваться командами fetch и merge, в явном виде указывая подлежащую слиянию информацию, *так как автоматизм команды git pull может привести к путанице*.

## Ликвидация веток с удаленного сервера

Предположим, работа с удаленной веткой закончилась, и программный компонент, над которым вы с коллегами трудились, слит в удаленную ветку master (или в ту ветку, где вы храните стабильный вариант кода). Теперь можно избавиться от удаленной ветки, добавив команде **git push** параметр **--delete**. А вот как выглядит удаление ветки serverfix с сервера:

    $ git push origin --delete serverfix
    To https://github.com/schacon/simplegit
    - [deleted] serverfix

По сути, эта команда просто удаляет с сервера указатель. Как правило, Git-сервер хранит данные, пока в дело не вступит сборщик мусора, поэтому, в случае ошибочного удаления, информацию зачастую легко восстановить.

