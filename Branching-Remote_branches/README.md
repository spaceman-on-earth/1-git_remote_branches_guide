# Preamble - Working with remotes

Guide to working with remotes. Russian edition.

---

Для совместной работы над проектами Git требуются навыки управления удаленными репозиториями. Удаленные репозитории представляют собой версии проекта, хранимые в Интернете или где-то в сети. Их может быть несколько, и каждый в общем случае доступен вам только для чтения или же для чтения и записи.  

Взаимодействие с другими пользователями предполагает управление удалёнными репозиториями, а также отправку и получение данных из них. Управление репозиториями включает в себя как умение добавлять новые, так и умение удалять устаревшие репозитории, а также умение управлять различными удалёнными ветками, объявлять их отслеживаемыми или нет и так далее.

## Отображение удаленных репозиториев (git remote)

Просмотр уже настроенных удаленных серверов осуществляется командой **git remote**. Она дает список коротких имен для всех указанных вами областей удаленной работы. Если репозиторий был клонирован, вы должны увидеть по крайней мере источник, то есть имя, которое Git по умолчанию присваивает клонируемому серверу:

    $ git clone https://github.com/schacon/ticgit
    Cloning into 'ticgit'...
    remote: Reusing existing pack: 1857, done.
    remote: Total 1857 (delta 0), reused 0 (delta 0)
    Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
    Resolving deltas: 100% (772/772), done.
    Checking connectivity... done.
    $ cd ticgit
    $ git remote
    origin

Параметр **-v** позволяет увидеть URL-адреса, которые Git хранит для сокращенного имени, используемого при чтении из данного удаленного репозитория и при записи в него:

    $ git remote -v
    Origin https://github.com/schacon/ticgit (fetch)
    Origin https://github.com/schacon/ticgit (push)

Если репозиториев несколько, они выводятся списком. Скажем, репозиторий с несколькими удаленными копиями для совместной работы с коллегами может выглядеть следующим образом:

    $ git remote -v
    bakkdoor https://github.com/bakkdoor/grit (fetch)
    bakkdoor https://github.com/bakkdoor/grit (push)
    cho45 https://github.com/cho45/grit (fetch)
    cho45 https://github.com/cho45/grit (push)
    defunkt https://github.com/defunkt/grit (fetch)
    defunkt https://github.com/defunkt/grit (push)
    koke git://github.com/koke/grit.git (fetch)
    koke git://github.com/koke/grit.git (push)
    origin git@github.com:mojombo/grit.git (fetch)
    origin git@github.com:mojombo/grit.git (push)

Это означает, что мы легко можем скачать себе изменения, внесенные любым из этих пользователей.

## Добавление удаленных репозиториев (git remote add)

Чтобы добавить такой репозиторий под коротким именем, которое упростит дальнейшие обращения к нему, используйте команду **git remote add [сокращенное имя] [url]**:

    $ git remote add pb https://github.com/paulboone/ticgit
    $ git remote -v
    origin https://github.com/schacon/ticgit (fetch)
    origin https://github.com/schacon/ticgit (push)
    pb https://github.com/paulboone/ticgit (fetch)
    pb https://github.com/paulboone/ticgit (push)

Теперь вместо полного URL-адреса в командную строку можно вводить имя pb. К примеру, для скачивания всей информации, которая есть у коллеги, но отсутствует у вас, используйте команду **git fetch pb**:

    $ git fetch pb
    remote: Counting objects: 43, done.
    remote: Compressing objects: 100% (36/36), done.
    remote: Total 43 (delta 10), reused 31 (delta 5)
    Unpacking objects: 100% (43/43), done.
    From https://github.com/paulboone/ticgit
    * [new branch] master -> pb/master
    * [new branch] ticgit -> pb/ticgit

Ветка master этого коллеги теперь доступна вам локально как pb/master. Вы можете выполнить ее слияние с одной из ваших веток или перейти в нее, если требуется просто проверить ее содержимое.

## Извлечение данных из удаленных репозиториев

Извлечение данных из удаленных проектов выполняется такой командой **git fetch [имя удаленного репозитория]**

Эта команда связывается с удаленным проектом и извлекает оттуда все пока отсутствующие у вас данные. После этого у вас должны появиться ссылки на все ветки удаленного проекта, которые можно подвергнуть слиянию или просмотреть.

Когда вы клонируете репозиторий, команда **git clone** автоматически добавляет этот удалённый репозиторий под именем «origin».  
Соответственно команда **git fetch origin** извлекает все, что появилось на этом сервере после его клонирования (или после момента последнего извлечения информации).  
Важно понимать, что команда git fetch помещает все данные в ваш локальный репозиторий, — *она не выполняет автоматическое слияние с ветками, с которыми вы работаете в данный момент, и вообще никак не затрагивает эти ветки*.  
Слияние вы выполните вручную, как только в этом возникнет необходимость.  

Если же у вас есть ветка, настроенная на слежение за какой-то удаленной веткой, команда **git pull** будет автоматически извлекать информацию из удаленной ветки и выполнять слияние с текущей веткой. В некоторых случаях такой порядок вещей оказывается проще и удобнее.  
Кроме того, по умолчанию команда **git clone** автоматически настраивает вашу локальную ветку master на слежение за удаленной веткой master (она может иметь и другое имя) на сервере, с которого вы выполняли клонирование.  
В общем случае команда **git pull** извлекает (fetch) данные с сервера, который вы клонировали, и автоматически пытается слить (merge) их с вашим текущим рабочим кодом.

## Отправка данных в удаленный репозиторий (git push)

Чтобы поделиться результатами своего труда, их нужно отправить в репозиторий. Это делается простой командой **git push [имя удаленного сервера] [ветка]**.

**Команда сработает только при условии**, что клонирование осуществлялось с сервера, где у вас есть доступ на запись, и за это время никто не отправлял туда свои данные. Если вы выполнили клонирование одновременно с другим пользователем и он уже отправил результаты своей работы на сервер, ваша попытка отправки данных окончится неудачей. Вам сначала нужно скачать все добавленное этим пользователем и встроить это в свои данные, и только после этого появится возможность воспользоваться командой git push.

## Просмотр удаленных репозиториев

Для получения дополнительной информации о конкретном удаленном репозитории применяется команда **git remote show [имя удаленного сервера]**.

    $ git remote show origin
    * remote origin
    Fetch URL: https://github.com/schacon/ticgit
    Push URL: https://github.com/schacon/ticgit
    HEAD branch: master
    Remote branches:
    master tracked
    dev-branch tracked
    Local branch configured for 'git pull':
    master merges with remote master
    Local ref configured for 'git push':
    master pushes to master (up to date)

Выводятся URL-адрес удаленного репозитория и информация об отслеживаемых ветках. Команда услужливо сообщает, что если, находясь в ветке master, вы запускаете команду git pull, ветка master с удаленного сервера будет автоматически слита с вашей сразу же после скачивания всех необходимых данных. Кроме того, она выводит на экран список всех скачанных ею ссылок.

## Удаление и переименование удаленных репозиториев

Переименование ссылок осуществляется командой **git remote rename**, меняющей сокращенные имена удаленных репозиториев.

Если по какой-то причине вы хотите удалить ссылку на удаленный репозиторий (например, вы поменяли сервер, больше не используете конкретное зеркало или участник проекта перестал вносить в него вклад), используйте команду **git remote rm**.

<br/>
<br/>
<br/>

# GIT REMOTE BRANCHES GUIDE

Guide to basic operations with remote branches in Git.  
Russian edition.  

---

Удаленные ветки представляют собой ссылки на состояния веток в удаленных репозиториях. Перемещать их локально вы не можете; они смещаются автоматически при каждом подключении по сети. Удаленные ветки работают как закладки, напоминающие, где в удаленных репозиториях находились соответствующие ветки во время вашего последнего подключения к ним.

Они имеют форму **(имя удаленного репозитория)/(ветка)**. К примеру, чтобы увидеть, как выглядела ветка master на сервере origin во время последнего взаимодействия с ним, проверьте ветку origin/master.  

Проясним ситуацию на примере. Предположим, у вас есть Git-сервер с адресом git.ourcompany.com. При клонировании с этого адреса Git автоматически присваивает копии имя origin, извлекает все данные, создает указатель на местоположение ветки master и присваивает ему локальное имя origin/master. Одновременно вам предоставляется собственная локальная ветка master, берущая начало в том же самом месте, что и одноименная ветка копии, что дает вам отправную точку для начала работы:

![Удаленный и локальный репозитории после клонирования](https://git-scm.com/book/en/v2/images/remote-branches-1.png "Удаленный и локальный репозитории после клонирования")

Если во время вашей работы на локальной ветке master кто-то отправит на сервер git.ourcompany.com результаты своего труда и обновит удаленную ветку master, истории веток будут развиваться по-разному. Кроме того, до момента связи с сервером origin указатель origin/master у вас двигаться не будет:

![Локальная и удалённая работа может расходиться](https://git-scm.com/book/en/v2/images/remote-branches-2.png "Локальная и удаленная версии ветки могут различаться")

Синхронизация работы осуществляется командой **git fetch origin**. Она ищет сервер с именем «origin» (в данном случае это сервер git.ourcompany.com), извлекает оттуда все пока отсутствующие у вас данные, обновляет вашу локальную базу данных и сдвигает указатель origin/master на новую, более актуальную позицию:

![Команда git fetch обновляет ссылки на удаленный репозиторий](https://git-scm.com/book/en/v2/images/remote-branches-3.png "Команда git fetch обновляет ссылки на удаленный репозиторий")

Чтобы продемонстрировать, как будут выглядеть удаленные ветки при наличии нескольких удаленных серверов, предположим, что у вас есть еще один внутренний сервер Git, которым пользуется только одна из групп разработчиков. Этот сервер находится по адресу git.team1.ourcompany.com. Добавить его в качестве новой удаленной ссылки на проект, над которым вы сейчас работаете, можно уже знакомой вам командой **git remote add**. Присвойте этому удаленному серверу имя teamone:

![Добавление еще одного удаленного сервера](https://git-scm.com/book/en/v2/images/remote-branches-4.png "Добавление еще одного удаленного сервера")

Теперь можно воспользоваться командой git fetch teamone и получить все данные, отсутствующие у вас, но имеющиеся на сервере teamone. Однако поскольку пока этот сервер содержит всего лишь часть данных с сервера origin, система Git ничего не скачает, а только сгенерирует удаленную ветку teamone/master, указывающую на тот же коммит, что и ветка master на сервере teamone:

![Удаленная отслеживающая ветка для ветки teamone/master](https://git-scm.com/book/en/v2/images/remote-branches-5.png "Удаленная отслеживающая ветка для ветки teamone/master")

## Отправка данных (git push)

Чтобы поделиться содержимым своей ветки с окружающими, ее нужно отправить на удаленный сервер, на котором у вас есть права на запись. Автоматической синхронизации локальных веток с удаленными серверами не происходит, поэтому ветки, которые вы хотите выставить на всеобщее обозрение, следует отправлять вручную. Такой подход дает возможность работать с личными ветками независимо от коллег, предоставляя доступ только к тематическим веткам, предназначенным для совместной работы.

Предположим, у вас есть ветка serverfix, над которой вы хотите работать вместе с коллегами. Ее следует отправить на сервер командой **git push (удаленный сервер) (ветка)**:

    $ git push origin serverfix
    Counting objects: 24, done.
    Delta compression using up to 8 threads.
    Compressing objects: 100% (15/15), done.
    Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
    Total 24 (delta 2), reused 0 (delta 0)
    To https://github.com/schacon/simplegit
    * [new branch] serverfix -> serverfix

Это в некотором роде сокращение. Система Git автоматически превращает имя ветки serverfix в запись refs/heads/serverfix:refs/heads/serverfix, что означает «возьмите мою локальную ветку serverfix и используйте для обновления удаленной ветки serverfix». Фрагмент refs/heads/, как правило, можно просто опустить. Вы также можете воспользоваться командой **git push origin serverfix:serverfix**, которая делает то же самое. Кроме того, данный формат позволяет переслать содержимое локальной ветки в удаленную ветку с другим именем. Достаточно вместо имени serverfix на удаленном сервере указать другой вариант, например **git push origin serverfix:awesomebranch**. В этом случае содержимое локальной ветки serverfix будет передано в ветку awesomebranch на удаленном сервере.  

> ПРИМЕЧАНИЕ  
> Каждый раз вводить свой пароль не нужно. Если для отправки данных вы используете протокол HTTPS, сервер Git будет просить вас указать имя пользователя и пароль для проверки прав доступа. По умолчанию эту информацию предлагается ввести в терминале, чтобы сервер мог сообщить вам, имеете ли вы право отправлять ему данные. Чтобы не делать этого при каждой отправке, настройте «кэш учетных данных». Проще всего несколько минут держать данную информацию в памяти, что легко достигается командой **git config --global credential.helper cache**.

Когда кто-то из ваших коллег в следующий раз решит скачать обновления с сервера, он получит ссылку в виде удаленной ветки origin/serverfix на то место, куда указывает серверная ветка serverfix:

    $ git fetch origin
    remote: Counting objects: 7, done.
    remote: Compressing objects: 100% (2/2), done.
    remote: Total 3 (delta 0), reused 3 (delta 0)
    Unpacking objects: 100% (3/3), done.
    From https://github.com/schacon/simplegit
    * [new branch] serverfix -> origin/serverfix

Имейте в виду, что получение новых удаленных веток при скачивании данных не означает автоматического появления их доступных для редактирования копий. Другими словами, у вас появляется не новая ветка serverfix, а только недоступный для редактирования указатель origin/serverfix.

Тем не менее, данные оттуда можно слить в текущую рабочую ветку, воспользовавшись командой **git merge origin/serverfix**. Если вам требуется собственная копия ветки serverfix, достаточно создать ее, взяв за основу удаленную ветку:

    $ git checkout -b serverfix origin/serverfix
    Branch serverfix set up to track remote branch serverfix from origin.
    Switched to a new branch 'serverfix'

В результате вы получаете для работы локальную ветку, которая начинается там же, где и ветка origin/serverfix.

## Слежение за ветками
 
При переходе в локальную ветку, созданную из удаленной, автоматически появляется так называемая ветка наблюдения (tracking branch). Это локальная ветка, напрямую связанная с удаленной. Если, находясь на этой ветке, вы наберете команду **git push**, система Git автоматически поймет, на какой сервер и в какую ветку нужно отправлять данные. А команда **git pull** в этом случае скачивает все удаленные ссылки и после этого автоматически выполняет слияние в соответствующую удаленную ветку.  
Ветка, за которой следит локальная называется «upstream branch».

При клонировании репозитория автоматически создается ветка master, следящая за веткой origin/master. Именно поэтому команды *git push и git pull выполняются из этой ветки без аргументов*. При желании можно создавать и другие ветки наблюдения, следящие за ветками на других удаленных серверах или не отслеживающие происходящее на ветке master. Простой пример реализации этого сценария — команда **git checkout -b [ветка] [имя удаленного сервера]/[ветка]**. Это достаточно распространенная операция, для которой в Git существует параметр --track:

    $ git checkout --track origin/serverfix
    Branch serverfix set up to track remote branch serverfix from origin.
    Switched to a new branch 'serverfix'

Если вы хотите, чтобы имя локальной ветки отличалось от имени удаленной ветки, используйте первую версию команды с указанием нового имени:

    $ git checkout -b sf origin/serverfix
    Branch sf set up to track remote branch serverfix from origin.
    Switched to a new branch 'sf'

Теперь локальная ветка sf поддерживает автоматический обмен данными с удаленной веткой origin/serverfix.

Если вы хотите сопоставить только что скачанной удаленной ветке существующую локальную ветку или поменять удаленную ветку, за которой вы следите, используйте параметр **-u** или **--set-upstream-to** команды git branch:

    $ git branch -u origin/serverfix
    Branch serverfix set up to track remote branch serverfix from origin.

Для обращения к существующей ветке наблюдения есть сокращенные формы **@{upstream}** или **@{u}**. К примеру, если из ветки master вы следите за веткой origin/master, для краткости можно писать git merge @{u} вместо git merge origin/master.

Получить список веток наблюдения позволяет параметр **-vv** команды git branch. В результате выводится перечень локальных веток с дополнительной информацией, касающейся того, за чем следит каждая ветка и на сколько она опережает соответствующую ветку на удаленном сервере или отстает от нее:

    $ git branch -vv
    iss53 7e424c3 [origin/iss53: ahead 2] forgot the brackets
    master 1ae2a45 [origin/master] deploying index fix
    * serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
    testing 5ea463a trying something new

Здесь мы видим, что ветка iss53 связана с веткой origin/iss53 и при этом запись «ahead 2» означает наличие двух локальных коммитов, пока не отправленных на сервер. Наша ветка master связана с веткой origin/master и содержит актуальную информацию. А вот ветка serverfix, связанная с веткой server-fix-good на сервере teamone, помечена как «ahead 3, behind 1», то есть на сервере существует коммит, который в нее пока не слит, а на ней присутствуют три коммита, пока не отправленные на сервер. Наконец, мы видим, что ветка testing не связана ни с одной удаленной веткой.

Отметим, что все цифры представляют собой показатели, зафиксированные в момент последнего скачивания данных с каждого сервера. Данная команда не обращается к серверам, а просто сообщает локальные данные из кэша. Для получения актуальной информации о количестве новых коммитов на локальных и удаленных ветках следует извлечь данные со всех удаленных серверов и только затем воспользоваться этой командой. Это можно сделать так:   
**$ git fetch --all; git branch -vv**.

## Получение данных с последующим слиянием (git pull)

Хотя команда **git fetch** забирает с сервера всю пока отсутствующую у вас новую информацию, на состояние рабочей папки она никак не влияет. Она всего лишь предоставляет данные, которые можно подвергнуть слиянию.  

Но существует и команда **git pull**, по сути, представляющая собой команду git fetch, за которой немедленно следует команда git merge. При наличии ветки наблюдения, настроенной, как показано в предыдущем разделе, вручную или в момент ее генерации командой clone или checkout, команда **git pull** будет обращаться к серверу и ветке, за которой наблюдает ваша текущая ветка, скачивать данные с этого сервера и пытаться слить их с вашей веткой.  

В общем случае лучше отдельно пользоваться командами fetch и merge, в явном виде указывая подлежащую слиянию информацию, *так как автоматизм команды git pull может привести к путанице*.

## Ликвидация веток с удаленного сервера

Предположим, работа с удаленной веткой закончилась, и программный компонент, над которым вы с коллегами трудились, слит в удаленную ветку master (или в ту ветку, где вы храните стабильный вариант кода). Теперь можно избавиться от удаленной ветки, добавив команде **git push** параметр **--delete**. А вот как выглядит удаление ветки serverfix с сервера:

    $ git push origin --delete serverfix
    To https://github.com/schacon/simplegit
    - [deleted] serverfix

По сути, эта команда просто удаляет с сервера указатель. Как правило, Git-сервер хранит данные, пока в дело не вступит сборщик мусора, поэтому, в случае ошибочного удаления, информацию зачастую легко восстановить.